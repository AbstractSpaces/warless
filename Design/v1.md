#WWW Version 1 Spec
* This version will just be a prototype for basic controls, physics and display
functionality.
* It will be a single machine, client only version. The second player won't have controls and only exists as a test dummy.
* Loosely following an MVC pattern to keep concerns separated and my sanity intact.

##Mechanics
###Map
* Square, two Bases and no other structures.
* Base takes 10 hits to kill.
* No turrets or projectiles yet.

###Warriors
* Both circles.
* Right-to-left quarter-circle Slash.
* Dash quadruples move speed for 0.5 seconds, brief invincibility.
* No parry.
* Three hits kill.

##2D Space
* Describing coordinates and dimensions as between 0 and 1. Hoping to multiply with canvas size to adapt to different resolutions.
* All rotations described in radians counter-clockwise from the positive x axis. Standard stuff.

###Modelling
* To use the SAT polygons need to provide the normals of their edges & the coordinates of their vertices.
* Given that SAT requires convex polygons, I'll describe edges so that their angle is always positive and the right-sided (i.e. outward) normal is provided.
* They also need to be compared under a common coordinate system. I'll calculate and store data for local coordinates at object creation, then transform it to the global system as needed for comparisons.
* Give polygons a global(origin, rot) method for returning a transformed copy of themselves.
* Make the collision algorithm a method of Mobile entities. Pass it the other entity's polygon, and the Mobile can correct its own position as necessary and return a Boolean on whether it collided.

##Collisions
* ~~By far the biggest headache at these initial stages.~~
	* Screw that, deciphering mixins suuuucked.


###Broad phase:
* Divide map into a discrete grid, cells sized so no object can span more than 2 cells along either axis.
* Create a mapping structure to associate game objects with the cell grids they occupy.
* Give each object a bounding box, objects mapped to the cells that each box corner lies in.
* Only check for collisions against objects sharing a cell and with overlapping AABB.

###Narrow phase:


##Grid Map


##Dev Journal
* Using Victor.js for vector calculations. My uni transcript is evidence enough that I know how to do them manually and I won't be innovating on how they are implemented, so this just saves some time.

* Despite avoiding my usual mistake and planning thoroughly before coding, I've still managed to end up lost in a swamp of inheritance and interfaces. A flaw in the paradigm, or my incompetence? Either way I want to try a new approach.

* That "new approach" ended up being a long and painful journey of making everything static and procedural (pain to work with all those parameters), imitating functional programming by exclusively using composition over inheritance (needlessly complex for types with an obvious hierarchy), learning that TypeScript class methods can be reassigned and spending days learning about the language's implementation of classes and how I could make my own system with immutable methods (a) an unnecessary feature that I really just wanted to see if I could produce, and b) any usable approach would either be convoluted and unreadable or involve redefining methods inside the class definition, introducing inefficiency), then just now figuring out you can make TypeScript methods immutable by casting the object to an interface with that method as a readonly property and finally feeling confident in my understanding of the tools and options available and how I should use them. It wasn't fun, but I think the journey was fruitful.

* I just discovered the separating axis theorem. While it's trickier than my initial idea, using it for collisions should pay dividends down the road as it can be applied to virtually any polygon.

* ~~Switching from Victor to GL-Matrix as it claims to be faster.~~ Screw it, I'm sick of defensive copying and API's not suited to the task. I'm going to make my own vector module.
